<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lab — Import PDF/TXT & Mini-Résumé (client-only)</title>
  <meta name="color-scheme" content="dark light" />

  <!-- PDF.js — version fixe, SRI retiré, worker aligné sur la même version -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    } else {
      console.warn('PDF.js failed to load; PDFs will be skipped.');
    }
  </script>

  <style>
    :root{
      --bg:#0a1220; --card:#0c1628; --text:#eef3f8; --muted:#a8b3c7; --pri:#6ee7ff; --ok:#37d399; --warn:#fbbf24; --err:#f87272;
      --border: #16233a;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f7f9fc; --card:#ffffff; --text:#0b1628; --muted:#5b6b83; --border:#e9eef6; }
    }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";}
    .wrap{max-width:980px;margin:0 auto;padding:24px;}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:20px}
    h1{font-size:clamp(20px,3vw,28px);margin:0}
    .muted{color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px;margin:12px 0}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .drop{border:2px dashed var(--border);border-radius:12px;padding:18px;text-align:center;cursor:pointer;transition:.15s}
    .drop:hover{border-color:var(--pri)}
    .btn{appearance:none;border:1px solid var(--border);background:transparent;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn.primary{background:var(--pri);border-color:transparent;color:#04121b}
    .btn.small{padding:6px 10px;font-size:13px}
    input[type="file"]{display:none}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:860px){ .grid{grid-template-columns:1fr 1fr} }
    .file-item{display:flex;flex-direction:column;gap:8px}
    .meta{font-size:12px;color:var(--muted)}
    textarea{width:100%;min-height:180px;background:#0000;color:var(--text);border:1px dashed var(--border);border-radius:10px;padding:10px;resize:vertical}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);color:var(--muted)}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    .kpi{display:flex;gap:16px;flex-wrap:wrap}
    .kpi .chip{border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:13px}
    .footer{color:var(--muted);font-size:12px;margin-top:16px}
    .right{margin-left:auto}
    .mono{font-family: ui-monospace, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Lab — PDF/TXT import & résumé (client-only)</h1>
      <div class="muted">Single-file / zéro backend</div>
    </header>

    <div class="card">
      <div class="row">
        <label class="drop" for="fileInput" id="dropArea" style="flex:1">
          <div><strong>Glisse-dépose</strong> ou clique pour importer des <strong>PDF</strong> / <strong>TXT</strong> / <strong>MD</strong></div>
          <div class="muted">Traitement 100% local dans ton navigateur</div>
        </label>
        <input id="fileInput" type="file" accept=".pdf,.txt,.md,.markdown" multiple />
        <button class="btn" id="clearBtn" title="Effacer la liste">Clear</button>
      </div>
      <div class="kpi" id="kpi">
        <div class="chip">Docs: <span id="kpiDocs">0</span></div>
        <div class="chip">Mots: <span id="kpiWords">0</span></div>
        <div class="chip">PDF.js: <span id="kpiPdf" class="mono"></span></div>
      </div>
    </div>

    <div id="files" class="grid"></div>

    <div class="card">
      <div class="row">
        <div class="muted">Résumé “client-only” (heuristique locale, pas d’API)</div>
        <button class="btn primary right" id="summAll">Résumer tout</button>
      </div>
      <div class="footer">
        Pour un vrai résumé LLM, branche un backend et remplace <code>summarizeLocally()</code> par un appel serveur. Ici, tout reste local.
      </div>
    </div>

    <div class="footer">Astuce CSP : autorise <code>script-src</code> et <code>worker-src</code> vers <code>cdn.jsdelivr.net</code> si tu as une CSP stricte.</div>
  </div>

  <script>
    // --- Helpers UI ---
    const el = sel => document.querySelector(sel);
    const filesEl = el('#files');
    const kpiDocs = el('#kpiDocs');
    const kpiWords = el('#kpiWords');
    const kpiPdf  = el('#kpiPdf');

    const state = {
      docs: [] // {name, type, text}
    };

    function fmtNumber(n){ return n.toLocaleString?.() ?? String(n); }

    function updateKPIs(){
      kpiDocs.textContent = state.docs.length;
      const words = state.docs.reduce((acc,d) => acc + (d.text?.split(/\s+/g)?.length || 0), 0);
      kpiWords.textContent = fmtNumber(words);
      kpiPdf.textContent = window.pdfjsLib ? 'OK' : 'N/A';
      kpiPdf.className = window.pdfjsLib ? 'ok mono' : 'warn mono';
    }

    function addDocCard(doc, index){
      const div = document.createElement('div');
      div.className = 'card file-item';
      div.innerHTML = `
        <div class="row" style="align-items:flex-start">
          <div>
            <div><strong>${escapeHtml(doc.name)}</strong></div>
            <div class="meta">${doc.type} · ${fmtNumber(doc.text.split(/\s+/g).length)} words</div>
          </div>
          <span class="tag right">${doc.type.endsWith('pdf')?'PDF':'TEXT'}</span>
        </div>
        <textarea spellcheck="false" data-idx="${index}">${escapeHtml(doc.text)}</textarea>
        <div class="row">
          <button class="btn small" data-action="copy" data-idx="${index}">Copy</button>
          <button class="btn small" data-action="summ" data-idx="${index}">Résumé</button>
          <span class="muted">Les traitements restent locaux au navigateur.</span>
        </div>
      `;
      filesEl.appendChild(div);
    }

    function escapeHtml(s){
      return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
    }

    // --- PDF extraction ---
    async function pdfToText(file){
      if (!window.pdfjsLib) throw new Error('PDF.js not loaded');
      const data = new Uint8Array(await file.arrayBuffer());
      const pdf = await pdfjsLib.getDocument({ data }).promise;
      let full = '';
      for (let p=1; p<=pdf.numPages; p++){
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const line = content.items.map(i => i.str).join(' ');
        full += line + '\n';
      }
      return full.trim();
    }

    async function readAsText(file){
      // Fichiers texte simples
      if (/\.pdf$/i.test(file.name)){
        if (!window.pdfjsLib) {
          console.warn('Skip PDF: PDF.js not available');
          return { name:file.name, type:file.type||'application/pdf', text:'[PDF non lu: PDF.js indisponible]' };
        }
        try{
          const text = await pdfToText(file);
          return { name:file.name, type:file.type||'application/pdf', text };
        }catch(err){
          console.error('PDF parse error', err);
          return { name:file.name, type:file.type||'application/pdf', text:`[Erreur lecture PDF] ${err.message||err}` };
        }
      } else {
        const text = await file.text();
        return { name:file.name, type:file.type||'text/plain', text };
      }
    }

    // --- Local “Résumé” (heuristique simple, pas LLM) ---
    function summarizeLocally(text, maxSent=6){
      // 1) découpe naïve en phrases
      const sentences = text
        .replace(/\s+/g,' ')
        .split(/(?<=[\.\!\?])\s+(?=[A-ZÀ-Ÿ])/)
        .filter(s => s.trim().length > 0);

      if (sentences.length <= maxSent) return text; // rien à faire

      // 2) score TF simple sur tokens alpha (sans stopwords pour la démo)
      const freq = Object.create(null);
      const tokenize = s => s.toLowerCase().match(/[a-zà-ÿ0-9]+/g) || [];
      for (const s of sentences){
        for (const t of tokenize(s)) freq[t] = (freq[t]||0)+1;
      }
      const maxf = Math.max(...Object.values(freq));

      // 3) score de phrase = somme des TF normalisés, + bonus pour longueur raisonnable
      const scored = sentences.map((s,i) => {
        const toks = tokenize(s);
        const tf = toks.reduce((a,t)=>a+(freq[t]/maxf),0);
        const len = toks.length;
        const lengthBonus = (len>6 && len<40) ? 0.2 : 0;
        return { i, s, score: tf/Math.max(1,len) + lengthBonus };
      });

      // 4) on prend les top-N et on remet dans l’ordre d’origine
      const top = scored.sort((a,b)=>b.score-a.score).slice(0, maxSent).sort((a,b)=>a.i-b.i);
      return top.map(x=>x.s).join(' ');
    }

    // --- Events ---
    el('#fileInput').addEventListener('change', async (e) => {
      await handleFiles(e.target.files);
      e.target.value = '';
    });

    const dropArea = el('#dropArea');
    ;['dragenter','dragover'].forEach(ev => dropArea.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropArea.style.borderColor = 'var(--pri)';
    }));
    ;['dragleave','drop'].forEach(ev => dropArea.addEventListener(ev, e => {
      e.preventDefault(); e.stopPropagation(); dropArea.style.borderColor = 'var(--border)';
    }));
    dropArea.addEventListener('drop', async (e) => {
      const files = e.dataTransfer?.files;
      if (files && files.length) await handleFiles(files);
    });

    async function handleFiles(fileList){
      const arr = Array.from(fileList);
      for (const f of arr){
        const doc = await readAsText(f);
        state.docs.push(doc);
        addDocCard(doc, state.docs.length-1);
      }
      updateKPIs();
    }

    filesEl.addEventListener('click', async (e) => {
      const btn = e.target.closest('button[data-action]');
      if (!btn) return;
      const idx = Number(btn.dataset.idx);
      const action = btn.dataset.action;
      const ta = filesEl.querySelector(`textarea[data-idx="${idx}"]`);
      if (!ta) return;

      if (action === 'copy'){
        try{
          await navigator.clipboard.writeText(ta.value);
          btn.textContent = 'Copied ✓';
          setTimeout(()=>btn.textContent='Copy', 900);
        }catch{
          alert('Copy failed — droit d’accès au presse-papiers refusé ?');
        }
      }
      if (action === 'summ'){
        ta.value = summarizeLocally(ta.value, 6);
      }
    });

    el('#summAll').addEventListener('click', () => {
      filesEl.querySelectorAll('textarea').forEach(ta => {
        ta.value = summarizeLocally(ta.value, 6);
      });
    });

    el('#clearBtn').addEventListener('click', () => {
      state.docs = [];
      filesEl.innerHTML = '';
      updateKPIs();
    });

    // Init KPIs
    updateKPIs();
  </script>
</body>
</html>
